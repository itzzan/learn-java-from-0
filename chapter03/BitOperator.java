//演示位运算操作符

public class BitOperator {

	//编写一个main方法
	public static void main(String[] args) {	

		//推导
		//1，先得到2的补码 - 原码：00000000 00000000 00000000 00000010 - 正数原反补相同
		//					补码：00000000 00000000 00000000 00000010
		//2. 再得到3的补码 - 原码：00000000 00000000 00000000 00000011
		//					补码：00000000 00000000 00000000 00000011
		//3. 再进行组合	  按位与：00000000 00000000 00000000 00000010
		//4. 转换成原码：		补码：00000000 00000000 00000000 00000010
		//					原码：00000000 00000000 00000000 00000010
		System.out.println(2 & 3);// 2
		

		//推导
		//1. 先得到-2的原码 - 原码：10000000 00000000 00000000 00000010
		//2. 得到-2的补码   - 反码：11111111 11111111 11111111 11111101
		//					 补码：11111111 11111111 11111111 11111110
		//3. 组合    	 按位取反：00000000 00000000 00000000 00000001 - 补码 - 也是原码
		System.out.println(~-2);// 1



		//推导
		//1，先得到2的补码 - 原码：00000000 00000000 00000000 00000010 - 正数原反补相同
		//					补码：00000000 00000000 00000000 00000010
		//2. 再得到3的补码 - 原码：00000000 00000000 00000000 00000011
		//					补码：00000000 00000000 00000000 00000011
		//3. 进行组合  		    ：00000000 00000000 00000000 00000011 - 即补码 == 原码
		System.out.println(2 | 3);// 3


		//推导
		//1. 得到2的补码，即原码：00000000 00000000 00000000 00000010
		//2. 组合     按位取反 ：11111111 11111111 11111111 11111101 - 补码
		//3. 转换成原码        ：11111111 11111111 11111111 11111100 - 反码
		//					  ：10000000 00000000 00000000 00000011 - 原码
		System.out.println(~2);// -3


		//推导
		//1，先得到2的补码 - 原码：00000000 00000000 00000000 00000010 - 正数原反补相同
		//					补码：00000000 00000000 00000000 00000010
		//2. 再得到3的补码 - 原码：00000000 00000000 00000000 00000011
		//					补码：00000000 00000000 00000000 00000011
		//3. 再进行组合  按位异或：00000000 00000000 00000000 00000001 - 补码 == 原码
		System.out.println(2 ^ 3);// 1
	}

}